# 博客站群部署操作手册（Ubuntu 24.04 + Docker）

适用范围：将 GitHub 仓库 `https://github.com/Behait/blogs` 的 Next.js 前端与 Strapi CMS，在服务器（2C/2G/40G SSD，Ubuntu 24.04，Docker 27.5.1）上以多子域名 `a.aicodeblog.cn`、`b.aicodeblog.cn`、`c.aicodeblog.cn` 部署运行。

## 1. 总览架构
- 后端：Strapi（统一内容与评论）+ PostgreSQL（生产数据库）。
- 前端：三套 Next.js 实例，分别绑定不同站点 ID 与域名。
- 入口：Nginx 反向代理 + HTTPS，将三域名代理到各自前端容器。
- 容器：`postgres`、`strapi`、`web_a`、`web_b`、`web_c`、`nginx`。

## 2. 前置准备
- DNS：为 `a.`、`b.`、`c.` 子域添加 `A` 记录指向服务器公网 IP。
- 防火墙：开放 `8080/tcp`、`8443/tcp`（如启用 UFW：`sudo ufw allow 8080,8443/tcp`）。
- 证书：建议使用 Certbot 申请三域名证书（或通配符）。
- 旧项目路径：历史项目位于 `/opt/aicodeblog/` 并已占用 80/443 端口，本项目将使用 8080/8443 端口，但通过域名可直接访问（无需输入端口号）：
  - `sudo mkdir -p /opt/blogs && sudo chown $USER:$USER /opt/blogs`

## 3. 路径规划与拉取代码
- 创建新工作目录：`sudo mkdir -p /opt/blogs && sudo chown $USER:$USER /opt/blogs`
- 拉取仓库：
```
cd /opt/blogs
git clone https://github.com/Behait/blogs.git .
```
（如不使用 GitHub，可用 `scp/rsync` 上传本地代码至 `/opt/blogs`）

## 4. 环境变量文件
- Strapi：在 `/opt/blogs/blogs-cms/.env.production` 写入：
```
NODE_ENV=production
HOST=0.0.0.0
PORT=1337
DATABASE_CLIENT=postgres
DATABASE_HOST=postgres
DATABASE_PORT=5432
DATABASE_NAME=blogs_cms
DATABASE_USERNAME=blog_user
DATABASE_PASSWORD=blog_pass_2024
APP_KEYS=<_hex1>,<_hex2>,<_hex3>,<_hex4>
API_TOKEN_SALT=<_hex>
ADMIN_JWT_SECRET=<_hex>
JWT_SECRET=<_hex>
```
- 前端：为三域分别创建 `/opt/blogs/blogs-web/.env.a`、`.env.b`、`.env.c`：
```
NODE_ENV=production
CMS_URL=http://strapi:1337
CMS_TOKEN=<稍后在 Strapi 后台创建>
CURRENT_SITE_ID=<CMS 中 Site 的 ID>
NEXT_PUBLIC_SITE_DOMAIN=<a.aicodeblog.cn 或 b./c.>
```
- 生成密钥（重复执行取值）：`openssl rand -hex 32`

## 5. Compose 编排（multi-sites.yml）
在 `/opt/blogs/multi-sites.yml` 新建：
```
version: "3.8"
services:
  postgres:
    image: public.ecr.aws/docker/library/postgres:16-alpine
    container_name: blogs-postgres
    restart: unless-stopped
    environment:
      POSTGRES_USER: blog_user
      POSTGRES_PASSWORD: blog_pass_2024
      POSTGRES_DB: blogs_cms
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U blog_user -d blogs_cms"]
      interval: 5s
      timeout: 3s
      retries: 10

  strapi:
    build:
      context: ./blogs-cms
      dockerfile: Dockerfile
    container_name: blogs-strapi
    restart: unless-stopped
    env_file:
      - ./blogs-cms/.env.production
    environment:
      NODE_OPTIONS: "--max-old-space-size=512"
    depends_on:
      postgres:
        condition: service_healthy
    volumes:
      - strapi_uploads:/usr/src/app/public/uploads
    ports:
      - "1337:1337"

  web_a:
    build:
      context: ./blogs-web
      dockerfile: Dockerfile
    container_name: blogs-web-a
    restart: unless-stopped
    env_file:
      - ./blogs-web/.env.a
    environment:
      NODE_ENV: "production"
      NODE_OPTIONS: "--max-old-space-size=768"
    depends_on:
      - strapi
    ports:
      - "3001:3000"

  web_b:
    build:
      context: ./blogs-web
      dockerfile: Dockerfile
    container_name: blogs-web-b
    restart: unless-stopped
    env_file:
      - ./blogs-web/.env.b
    environment:
      NODE_ENV: "production"
      NODE_OPTIONS: "--max-old-space-size=768"
    depends_on:
      - strapi
    ports:
      - "3002:3000"

  web_c:
    build:
      context: ./blogs-web
      dockerfile: Dockerfile
    container_name: blogs-web-c
    restart: unless-stopped
    env_file:
      - ./blogs-web/.env.c
    environment:
      NODE_ENV: "production"
      NODE_OPTIONS: "--max-old-space-size=768"
    depends_on:
      - strapi
    ports:
      - "3003:3000"

  nginx:
    image: nginx:alpine
    container_name: blogs-nginx
    restart: unless-stopped
    depends_on:
      - web_a
      - web_b
      - web_c
    ports:
      - "8080:80"
      - "8443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/conf.d/default.conf:ro
      - /etc/letsencrypt:/etc/letsencrypt:ro

volumes:
  postgres_data:
  strapi_uploads:
```

## 6. Dockerfile（如仓库未附带，可新建）
- `/opt/blogs/blogs-cms/Dockerfile`：
```
FROM node:18-alpine
WORKDIR /usr/src/app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
ENV NODE_ENV=production
RUN npm run build
EXPOSE 1337
CMD ["npm","run","start"]
```
- `/opt/blogs/blogs-web/Dockerfile`：
```
FROM node:18-alpine AS deps
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

FROM node:18-alpine AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .
ENV NODE_ENV=production
RUN npm run build

FROM node:18-alpine AS runner
WORKDIR /app
ENV NODE_ENV=production
COPY --from=builder /app ./
EXPOSE 3000
CMD ["npm","run","start"]
```

## 7. Nginx 配置
- 在 `/opt/blogs/nginx/nginx.conf` 写入（示例为 a 域，b/c 复制改名）：
```
upstream web_a { server blogs-web-a:3000; }
server {
  listen 80;
  server_name a.aicodeblog.cn;
  return 301 https://$host$request_uri;
}
server {
  listen 443 ssl http2;
  server_name a.aicodeblog.cn;
  ssl_certificate     /etc/letsencrypt/live/a.aicodeblog.cn/fullchain.pem;
  ssl_certificate_key /etc/letsencrypt/live/a.aicodeblog.cn/privkey.pem;
  location / {
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_pass http://web_a;
  }
}
```
- 将以上 `a.aicodeblog.cn` 复制两份为 `b.` 与 `c.`，并将 `upstream`/`server_name`/`proxy_pass` 对应改为 `web_b` 与 `web_c`。

## 8. 证书申请（建议）
- 由于 80 端口已被现有项目占用，需要临时停止现有 Nginx 或使用 DNS 验证方式：
```
# 方法1：临时停止现有 Nginx 服务（如可接受短暂停机）
sudo systemctl stop nginx  # 或 docker stop <现有nginx容器>
sudo snap install core; sudo snap refresh core
sudo snap install --classic certbot
sudo ln -s /snap/bin/certbot /usr/bin/certbot
sudo certbot certonly --standalone -d a.aicodeblog.cn
sudo certbot certonly --standalone -d b.aicodeblog.cn
sudo certbot certonly --standalone -d c.aicodeblog.cn
sudo systemctl start nginx  # 或 docker start <现有nginx容器>

# 方法2：使用 DNS 验证（不需要停止现有服务）
sudo certbot certonly --manual --preferred-challenges dns -d a.aicodeblog.cn
sudo certbot certonly --manual --preferred-challenges dns -d b.aicodeblog.cn
sudo certbot certonly --manual --preferred-challenges dns -d c.aicodeblog.cn
```
（通配符 `*.aicodeblog.cn` 需 DNS-01 验证，按需选择）

## 9. 启动与初始化
1) 构建并启动数据库、后端：
```
cd /opt/blogs
docker compose -f multi-sites.yml up -d --build postgres
docker compose -f multi-sites.yml up -d --build strapi
```
2) 初始化 Strapi：访问 `http://<服务器IP>:1337/admin` 创建管理员；在设置里创建 `API Token (Full Access)`；在 CMS 中创建三个 `Site` 实体（域名对应 a/b/c），记录各自 ID；配置 CORS 允许三域来源。
3) 启动三套前端：
```
docker compose -f multi-sites.yml up -d --build web_a web_b web_c
```
4) 启动 Nginx：
```
docker compose -f multi-sites.yml up -d --build nginx
```
5) 验收访问：`https://a.aicodeblog.cn`、`https://b.aicodeblog.cn`、`https://c.aicodeblog.cn`

## 10. 资源与维护
- 内存限制：已在容器中用 `NODE_OPTIONS=--max-old-space-size=512/768` 控制 Node 堆，适配 2GB。
- 日志：
```
docker compose -f multi-sites.yml logs -f strapi
docker compose -f multi-sites.yml logs -f web_a
docker compose -f multi-sites.yml logs -f nginx
```
- 重启：`docker compose -f multi-sites.yml restart <服务名>`
- 备份：
```
docker exec -it blogs-postgres pg_dump -U blog_user blogs_cms > /opt/backups/blogs_cms_$(date +%F).sql
# 上传文件卷
docker run --rm -v strapi_uploads:/data -v /opt/backups:/backup alpine sh -c 'tar czf /backup/uploads_$(date +%F).tar.gz -C /data .'
```
- 更新代码（GitHub）：
```
cd /opt/blogs && git pull
docker compose -f multi-sites.yml up -d --build
```

## 11. 常见问题
- 502 网关错误：检查 `web_*` 是否运行、`CURRENT_SITE_ID` 是否与 CMS 中 Site ID 一致。
- 证书失败：确认 `server_name` 与证书路径正确、DNS 已指向本机；如端口占用，先停止 Nginx 再用 `certbot --standalone`。
- CORS 报错：在 Strapi 中允许来源域名（或在 `config/middlewares.ts` 配置 CORS）。

## GitHub 上传与服务器推送（快速步骤）
- 初始化并推送到 GitHub（如已设置远程可跳过 `remote add`）：
```
cd /opt/blogs

# 首次使用需要配置Git用户信息
git config --global user.email "your-email@example.com"
git config --global user.name "Your Name"

git init
git remote add origin https://github.com/Behait/blogs.git || true
git branch -M main
git add .
git commit -m "Initial deploy"
git push -u origin main
```

- 完整的 GitHub push 命令（后续更新代码时使用）：
```
# 添加所有更改的文件
git add .

# 提交更改，添加描述信息
git commit -m "更新描述：添加了新功能/修复了问题/更新了配置"

# 推送到远程仓库的main分支
git push origin main

# 如果遇到冲突，可以先拉取远程更改再推送
git pull origin main --rebase
git push origin main
```

- 完整的 GitHub pull 命令（从远程仓库获取更新）：
```
# 切换到项目目录
cd /opt/blogs

# 获取远程仓库的所有更改
git fetch origin

# 合并远程更改到本地
git pull origin main

# 如果有冲突，解决冲突后继续
# 1. 编辑冲突文件，解决冲突
# 2. 添加解决后的文件
git add .
# 3. 继续rebase过程（如果使用了rebase）
git rebase --continue
# 或者提交合并结果（如果使用了merge）
git commit -m "解决合并冲突"
```

- 将配置文件推送到服务器路径（替换 `<USER>` 与 `<IP>`）：
```
# 推送 Compose 文件与 Nginx 配置到 /opt/blogs
scp G:/code/blogs/multi-sites.yml <USER>@<IP>:/opt/blogs/multi-sites.yml
scp -r G:/code/blogs/nginx <USER>@<IP>:/opt/blogs/nginx
```

## Strapi 仅内网访问与管理方式
- 我们已在 `multi-sites.yml` 取消了 `strapi` 的 `ports` 映射，后端仅可在容器网络中被访问（前端通过 `strapi:1337` 访问）。
- 如需管理 Strapi Admin（不暴露公网端口），建议使用 SSH 隧道：
```
# 1) 在服务器查询 Strapi 容器 IP
CONTAINER_IP=$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' blogs-strapi)
# 2) 在本地建立 SSH 隧道（将本地 1337 转发到容器 1337）
ssh -N -L 1337:${CONTAINER_IP}:1337 <USER>@<IP>
# 3) 本地浏览器访问 http://localhost:1337/admin 进行后台管理
```
- 另一种临时运维方式：在维护窗口短暂暴露端口（修改 `multi-sites.yml` 为 `1337:1337` 并重启），完成操作后立刻移除端口映射。

## 12. 是否需要先上传到 GitHub？
- 非必须。可直接将本地代码上传到服务器并部署。
- 建议使用 GitHub（或其他私有 Git）：便于版本管理、备份、团队协作与后续 CI/CD。当前仓库地址：`https://github.com/Behait/blogs`。

—— 完整按本手册执行，可在你的服务器上快速完成多域部署。